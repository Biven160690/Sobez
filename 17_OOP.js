// ОПП ===============================================

// Объектно-ориентированное программирование (ООП) — это шаблон проектирования программного обеспечения, который позволяет решать задачи с точки зрения объектов и их взаимодействий.
// ООП обычно реализуется с помощью классов или прототипов. 
//JavaScript реализует ООП через прототипное наследование.(1)
// Принцип ООП заключается в том, чтобы составлять систему из объектов, решающих простые задачи, которые вместе составляют сложную программу.

//Наследование ====================================
// Наследование способствует повторному использованию кода, но зачастую приходится брать больше, чем нужно. Наследование позволяет ускорить разработку за счёт повторного использования кода.
// В классовом ООП классы являются чертежами для объектов. Объекты (или экземпляры) создаются на основе классов. Существует конструктор, который используется для создания экземпляра класса с заданными свойствами. Если мы изменим класс то изменется все объекты которые являються экземпляром этого класса. ПРи классовом наследовании класс который наследует свойтсва от родителя не может  знать какте свойтсва есть у родителя.
// В прототипном наследовании классы не используются совсем. Вместо этого объекты создаются из других объектов. Мы начинаем с обобщённого объекта — прототипа. Прототип можно использовать для создания других объектов путём его клонирования или расширять его разными функциями.
// Фабричная функция — это функция, которая принимает несколько аргументов и возвращает новый объект, состоящий из этих аргументов. 
//Помни что только те методы которые в прототипе есть будут наследоваться дочерним элементом

// В свойстве prototype есть много методов, разделённых на акцессоры (не изменяют исходный массив), мутаторы (изменяют исходный массив) и итераторы (применяют функцию, переданную в качестве аргумента, на каждом элементе массива для создания нового).

// Создание объекта - литераты, фабричная функция, Object.create()


//Инкапсуляция=========================================================
//Инкапсуляция защищает от влияния извне внутренние переменные каждого объекта; сокрытие внутренних процессов; свойство системы, позволяющее объединить данные и методы, работающие с ними, в классе и скрыть детали реализации от пользователя.В идеале программа должна состоять из «островов объектов»: каждый из них со своими состояниями, передающий сообщения туда и обратно. 
// const Customer = {
//   plan: 'trial'
// }
// Customer.setPremium = function() {
//   this.plan = 'premium'
// }
// Теперь мы можем добавить в объект user методы и поля Customer:

// User.customer = Customer
// user.customer.setPremium()
// После выполнения этих двух строк объект user будет выглядеть так:

// {
//  firstName: 'Dan',
//  lastName: 'Abramov',
//  email: 'dan@abramov.com',
//  password: 'iLuvES6',
//  customer: { plan: 'premium', setPremium: [Function] } - скрыт внутренний процесс!!!!!!!!!!!!!!!!!!
// }

//Полиморфизм ========================================================
// Полиморфизм позволяет описывать поведение вне зависимости от типа данных. В ООП это означает создание класса или прототипа, который может быть адаптирован объектами, работающими с другими типами данных. Объекты, которые используют полиморфный класс/прототип, должны определить специфичное для типа данных поведение, чтобы всё заработало
// function Maybe({data, status}) {
//   this.data = data
//   this.status = status
// }
// Maybe.prototype.apply = function (f) {
//   if(this.status) {
//     return new Maybe({data: f(this.data), status: this.status})
//   }
//   return new Maybe({data: this.data, status: this.status})
// }
// Maybe.prototype.getOrElse = function (msg) {
//   if(this.status) return this.data
//   return msg
// }
// function Number(data) {
//   let status = (typeof data === 'number')
//   Maybe.call(this, {data, status})
// }

// Number.prototype = Object.create(Maybe.prototype)

// function String(data) {
//   let status = (typeof data === 'string')
//   Maybe.call(this, {data, status})
// }
// String.prototype = Object.create(Maybe.prototype)

// const increment = num => num + 1
// const split = str => str.split('')

// let numValid = new Number(12)
// let numInvalid = new Number("foo")
// let strValid = new String("hello world")
// let strInvalid = new String(-1)

// let a = numValid.apply(increment).getOrElse('TypeError!')
// let b = numInvalid.apply(increment).getOrElse('TypeError Oh no!')
// let c = strValid.apply(split).getOrElse('TypeError!')
// let d = strInvalid.apply(split).getOrElse('TypeError :(')
// console.log(b)

// Композиция========================================================
// Как упоминалось ранее, существует нечто гораздо более простое, чем классы/прототипы — функциональная композиция. Её легко можно использовать снова, она инкапсулирует внутренние состояния, выполняет операции на любом типе данных и может быть полиморфной.

// const Person = {
//   firstName: 'firstName',
//   lastName: 'lastName',
//   getFullName: function() {
//     return `${this.firstName} ${this.lastName}`
//   }
// }
// // Теперь мы можем использовать объект Person таким образом:
// let person = Object.create(Person)

// person.getFullName() //> "firstName lastName"

// // Присваиваем значения переменным внутреннего состояния
// person.firstName = 'Dan'
// person.lastName = 'Abramov'

// // Получаем к ним доступ
// person.getFullName() //> "Dan Abramov"

// // Создадим объект User, склонировав объект Person, и добавим туда дополнительные данные и функции:

// const User = Object.create(Person)
// User.email = ''
// User.password = ''
// User.getEmail = function() {
//   return this.email
// }
// // Затем мы можем создать экземпляр User с помощью Object.create():

// let user = Object.create(User)
// user.firstName = 'Dan'
// user.lastName = 'Abramov'
// user.email = 'dan@abramov.com'
// user.password = 'iLuvES6'

// console.log(Person.password)

//Абстракция

// Представьте, что водитель едет в автомобиле по оживлённому участку движения. Понятно, что в этот момент он не будет задумываться о химическом составе краски автомобиля, особенностях взаимодействия шестерён в коробке передач или влияния формы кузова на скорость (разве что, автомобиль стоит в глухой пробке и водителю абсолютно нечем заняться). Однако, руль, педали, указатель поворота (ну и, возможно, пепельницу) он будет использовать регулярно.

// Абстрагирование – это способ выделить набор значимых характеристик объекта, исключая из рассмотрения незначимые. Соответственно, абстракция – это набор всех таких характеристик.