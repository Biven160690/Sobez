//function Cat(color, name) {
   //this.color = color
    //this.name = name
////}
//const cat = new Cat('Sergey', 'red')
//console.log(cat)

//Когда функция вызывается как new , происходит следующее:

   /// Создаётся новый пустой объект, и он присваивается this.
   // Выполняется код функции. Обычно он модифицирует this, добавляет туда новые свойства.
   // Возвращается значение this.

//function Dog(name, color) {
    //this.name = name
    //this.color = color
    
//}
//Dog.prototype.set = function () {
    //console.log(`${this.name} + ${this.color}`)
    
//}
//const cat = new Dog ('Sergey', ' red')
//cat.set() 
//каждый объект имеет свой прототип который береться от родительского элемента 
//из которого был создан данный объект. для того чтоб получить этот родительский прототип

//сейчас используют _proto_.... позволяет нам расширять свойсвта родительского 
//элемента (не копировать  а просто создать объекта на его основе)В JavaScript объекты имеют специальное скрытое свойство [[Prototype]] (так оно названо в спецификации), которое либо равно null, либо ссылается на другой объект. Этот объект называется «прототип»:
//let animal = {
    //eats: true
 // };
  //let rabbit = {
  //  jumps: true
  //};
  
  //rabbit.__proto__ = animal; // (*)
  
  // теперь мы можем найти оба свойства в rabbit:
 // alert( rabbit.eats ); // true (**)
  //alert( rabbit.jumps ); // true

 // function Person() {}
 // Person.prototype.legs = 2
  //Person.prototype.skin = 'red'

  //const person = new Person()
  //person.name = "Sergey"
  //console.log(person.legs)
  //console.log(person.name)
//Определяем какие свойства прототипа а какие свойства собственные
//console.log(person.hasOwnProperty('name'))
//console.log(person.hasOwnProperty('legs'))
//создаем объекты используя уже существующий прототип

//Ёще один спопособ наследования!!!!!!
//let Dog = {name: "Sergey", color: "red"}

//const day = Object.create(Dog) //первым параметром передаеться объект который будет являться прототипом 
//console.log(day.name)
//Dog.name = "Bata"
//console.log(day.name)
//Dog = {name: "Sergey1", color: "red1"} // мы изменили свойство объекта в дочернем объекте они останунься старые... 
//Асинхронность

//Когда будет собеседование  и я не смогу словами объяснить что здесь происходит ------я немного подзабыл теорию давайте на примере я покажу как я правильно понячл вопрос...и правильно ли я понимаю что этот код относиться к этой концепции

const ttt = ()=> {
    console.log('First')
}
const ddd = ()=> {
    console.log('Second')
}
const www = ()=> {
    console.log('Third')
}
ttt() //интерпритаотор закидывает функцию в колстек она выполняется и он ее выкидывает 
 setTimeout(ddd(), 0 ) // сам JS не понимает как работаь с этим и поэтому он использует стороние API/ закидвает на стронний, говорит что выполнить...затем выкидвает из колстека и он чист
www()//интерпритаотор закидывает функцию в колстек она выполняется и он ее выкидывает 
//после выпорлнения функции www стронний API видит что переданная ей функции моментальная и помещает ее в колбеккью он выкидвает ее в колстек и она выполняеться 