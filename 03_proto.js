

//=======================Прототип================================

// это механизм, с помощью которого объекты JavaScript наследуют свойства друг от друга.В программировании такой механизм называется «прототипным наследованием»,
// у каждого объекта есть прототип который он берет от родительского элемента.
//Любой объект создан при помощи класса или функции-конструктор!!!
//Объекты имеют __proto__ и какие-то __proto__ этих объектов равны prototype других объектов

// function Sergey (){
// }
// console.log(Sergey.__proto__ == Function.prototype)


//Кажды объект в JS  имеет __proto__.... Примитивные типы, когда к ним обращаемся как к объекту, то создаеться в памяти объектная версия и он тоже рассматриваеться как объект....Для того чтоб получить  родительский прототип сейчас используют __proto__ (свойтсва родительского элемента)

//let animal = {
    //eats: true
 // };
  //let rabbit = {
  //  jumps: true
  //};
  
  //rabbit.__proto__ = animal; // (*)
  
  // теперь мы можем найти оба свойства в rabbit:
 // alert( rabbit.eats ); // true (**)
  //alert( rabbit.jumps ); // true

  //Когда объекты созданы одинаковыми классами(типы их равны) то и их __proto__ будут равны:

//   let a = {}
//   let b = {}
//   console.log(a.__proto__ == b.__proto__)


// Prototype - это объект, который в основном представляет собой контейнер для хранения свойств и методов, которые мы хотим наследовать объектами, расположенными дальше по цепочке прототипов, свойство F.prototype (не путать с [[Prototype]]) устанавливает[[Prototype]] для новых объектов при вызове new F(). Значение F.prototype должно быть либо объектом, либо null.
// Объекты которыми являються классы или функции имеют  prototype. Рrototype - независимый объект сам по себе, с определенными свойствами и методами. У каждой функции по умолчанию уже есть свойство "prototype". По умолчанию "prototype" – объект с единственным свойством constructor, которое ссылается на функцию-конструкторонструктор.Стрелочная функция не имеет  prototype.

// Это удобно, когда у нас есть объект, но мы не знаем, какой конструктор использовался для его создания (например, он мог быть взят из сторонней библиотеки), а нам необходимо создать ещё один такой объект.

// function Rabbit(name) {
//   this.name = name;
//   console.log(name);
// }
// let rabbit = new Rabbit("White Rabbit");
// let rabbit2 = new rabbit.constructor("Black Rabbit");


//prototype так же позволяет нам расширять прототип  родительского элемента и передавать свойтсва объектам вызванным череp new
// function Dog(name, color) {
//     this.name = name
//     this.color = color
    
// }
// Dog.prototype.set = function () {
//     console.log(`${this.name} + ${this.color}`)
// }

// const cat = new Dog ('Sergey', ' red')
// cat.set() 

//  function Person() {}
//  Person.prototype.legs = 2
//  Person.prototype.skin = 'red'

//   const person = new Person()
//   person.name = "Sergey"
//   console.log(person.legs)
//   console.log(person.name)


//Когда нет в объекте нужного метода то  происходит следующее:

 //__proto__ => (ищет в prototype)


//=======================Ёще один спопособ наследования ===========================================

// let Dog = {name: "Sergey", color: "red"}
// const day = Object.create(Dog) //первым параметром передаеться объект который будет являться прототипом 
// // console.log(day.name)
// Dog.name = "Bata"
// // console.log(day.name)
// Dog = {name: "Sergey1", color: "red1"} 
// console.log(day.color)

//******************** при изменении свойств у родителя они меняються и у наследуемого объекта; если мы меняем  полностью  объект (будут новые свойтва, у наследуемого объекта останутся старые свойства родительского объекта)

// Object.prototype.sayHello = function () {
//     console.log('Hello')
// }
// //Благодаря  этой конструкции мы расширили базовый прототтип класса обжект и добавлилт новый метод....прпототим это объект который присутсвует у родительских элементов...



// var ser  = new Object ()
// ser.sayHello()

//=======================Асинхронность===========================

// EVENT LOOP - загребает микро и макро таски и работает с асинхронными функциями   --- кидает их в call stack согласно их очереди (сразу микро таски а потом макро). Цикл событий.....
//Когда будет собеседование  и я не смогу словами объяснить что здесь происходит ------я немного подзабыл теорию давайте на примере я покажу как я правильно понячл вопрос...и правильно ли я понимаю что этот код относиться к этой концепции

// const ttt = ()=> {
//     console.log('First')
// }
// const ddd = ()=> {
//     console.log('Second')
// }
// const www = ()=> {
//     console.log('Third')
// }
// ttt() 
//  setTimeout(ddd(), 0 )
// www()

//call stack - это механизм который отслеживает интерпритаторв скрипте....когда скрипт вызывает функцию интерпритатор добовляет ее в стек и обрабатывает ее...любая функция вызванная этой фукцией будет передана в стек вызовов....когда фукциф завершилась интерпритатор снимает эту фукцию  и возобновляет выполнение кода с тго места где остановился...
// Web Api  - интерфейс прикладного программирования  ....есть API браузера  API сторонни 


// Интерпрититар идет по нашему коду и закидвает все наши синхронные функции в call stack....если у намс есть асинхронная функция то происходит следующее:
// 1. Она попадает в call stack регистрируеться, дальше она поадает в в сторонний Web Apis, который будет  ее выполнять... она выполняеться ..в данном случае проходит 0 секунд... после этого она попадает в callback Queue там она находится в очереди и цикл (Event Loop) проходит и находит выполненые функции и согласно очереди закыдвает ее в  call stack где она и будет выполненна..